<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>NYC Electricity Grid Tracker - Accurate Boundaries</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      background-color: white;
      color: #000;
    }
    #map {
      height: 90vh;
      width: 100%;
    }
    #info {
      margin-top: 10px;
    }
  </style>
</head>
<body>

<h2>New York City Electricity Grid Tracker - Within Boundaries</h2>
<div id="map"></div>
<div id="info">Click a grid point for status details</div>

<!-- Leaflet and Turf.js libraries -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
  // NYC lat/lng bounding box - rectangular approx
  const latMin = 40.4774;
  const latMax = 40.9176;
  const lngMin = -74.2591;
  const lngMax = -73.7004;

  // NYC polygon boundary GeoJSON (simplified approx)
  const nycPolygon = turf.polygon([[
    [-74.2591, 40.9176],
    [-74.2591, 40.4774],
    [-73.7004, 40.4774],
    [-73.7004, 40.9176],
    [-74.2591, 40.9176]
  ]]);

  // Initialize Leaflet map with zoom and bounds restricted to NYC area
  const nycBounds = L.latLngBounds([latMin, lngMin], [latMax, lngMax]);
  const map = L.map('map', {
    maxBounds: nycBounds,
    maxBoundsViscosity: 1.0,
    minZoom: 11,
    maxZoom: 15
  }).setView([40.7128, -74.0060], 12);

  // Light tiles from OpenStreetMap
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);

  // Generate grid points strictly inside NYC polygon
  function generateGridPoints(count) {
    const points = [];
    while (points.length < count) {
      const lat = latMin + Math.random() * (latMax - latMin);
      const lng = lngMin + Math.random() * (lngMax - lngMin);
      const pt = turf.point([lng, lat]);
      if (turf.booleanPointInPolygon(pt, nycPolygon)) {
        points.push({ id: 'G' + (points.length + 1), lat, lng });
      }
    }
    return points;
  }

  const gridPoints = generateGridPoints(100);

  // Random status generator for simulation
  function getRandomStatus() {
    const statuses = ['Normal', 'High Load', 'Outage', 'Maintenance'];
    return statuses[Math.floor(Math.random() * statuses.length)];
  }

  // Create Leaflet circle markers for grid points
  const markers = gridPoints.map(point => {
    const marker = L.circleMarker([point.lat, point.lng], {
      radius: 6,
      fillColor: 'green',
      color: '#000',
      weight: 1,
      opacity: 1,
      fillOpacity: 0.8
    }).addTo(map);

    marker.status = getRandomStatus();
    marker.bindPopup(`<b>Grid Point ${point.id}</b><br>Status: ${marker.status}`);

    marker.on('click', () => {
      document.getElementById('info').innerHTML = `<b>Grid Point ${point.id}</b> Status: ${marker.status}`;
    });

    return marker;
  });

  // Update marker statuses every 5 seconds with color coding
  function updateStatuses() {
    markers.forEach(marker => {
      marker.status = getRandomStatus();
      let color;
      switch(marker.status) {
        case 'Normal': color = 'green'; break;
        case 'High Load': color = 'orange'; break;
        case 'Outage': color = 'red'; break;
        case 'Maintenance': color = 'blue'; break;
      }
      marker.setStyle({ fillColor: color });
      marker.setPopupContent(`<b>Grid Point ${marker._leaflet_id}</b><br>Status: ${marker.status}`);
    });
  }

  setInterval(updateStatuses, 5000);
</script>

</body>
</html>
